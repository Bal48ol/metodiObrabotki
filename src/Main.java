import java.io.IOException;

/*
java.awt.Color - библиотека для работы с цветами в Java.
java.awt.Graphics - библиотека для рисования на различных поверхностях в Java.
java.awt.image.BufferedImage - библиотека для работы с изображениями в Java.
java.io.File - библиотека для работы с файлами в Java.
javax.imageio.ImageIO - библиотека для чтения и записи изображений в Java.
java.io.IOException - это исключение, которое может быть выброшено при работе с файлами в Java.
java.awt.Graphics2D - предоставляет функциональность для рисования на экране с использованием 2D графики.
java.awt.RenderingHints содержит константы, используемые для управления параметрами рендеринга.
java.awt.geom.AffineTransform позволяет выполнять преобразования над графическими объектами.

Эти библиотеки являются стандартными библиотеками Java.
Они входят в стандартный пакет java.
*/

public class Main {
    public static void main(String[] args) throws IOException {

        //Модуль 1

        /* Черно-белое изображение из цветного. используется формула, которая переводит цветное изображение в черно-белое, используя требуемые коэффициенты для каждого цветового канала.
        Эти коэффициенты были получены экспериментально и дают наилучший результат при конвертации в черно-белое. */
        ConvertToGrayscale.convertToGrayscale();

        /* Гистограмма яркости. Для создания гистограммы программа проходит по всем пикселям изображения и подсчитывает количество пикселей с каждой возможной яркостью.
        Затем она рисует прямоугольники на новом изображении (размером 256x256), соответствующие значениям яркости из гистограммы. */
        BrightnessHistogram.brightnessHistogram();

        /* Негатив. В этом коде мы загружаем изображение из файла "input_image.jpg" и проходим по каждому пикселю.
        Для каждого пикселя мы вычисляем инвертированное значение для негатива и инвертированное значение с порогом яркости.
        Для негатива мы просто инвертируем значения компонент RGB. Для негатива с порогом мы определяем пороговое значение яркости и, если яркость пикселя больше этого порога,
        то оставляем его без изменений. В противном случае мы инвертируем значения компонент RGB для получения негатива с порогом.
        Затем мы записываем полученные изображения в файлы "negative_image.jpg" и "negative_threshold_image.jpg". */
        NegativeImage.negativeImage();
        NegativeWithThreshold.negativeWithThreshold();

        /* Пороговое преобразование. проходим по каждому пикселю. Для каждого пикселя мы вычисляем значение яркости путем среднего арифметического значений компонент RGB.
        Затем мы сравниваем значение яркости с пороговым значением. Если оно больше порога, то устанавливаем значения компонент RGB равными 255 (белый цвет),
        иначе - равными 0 (черный цвет). Затем мы создаем новое значение пикселя на основе измененных значений компонент RGB и записываем его в изображение.
        Наконец, мы сохраняем полученное преобразованное изображение в файл. */
        PorogPreobraz.porogPreobraz();

        /* Повышение и понижение контраста. Здесь мы просто добавили метод adjustContrast в класс и вызываем его дважды с разными значениями коэффициента контрастности для увеличения и
        уменьшения контрастности изображения соответственно. */
        ImageContrast.imageContrast();

        /* Гамма-преобразование. Здесь мы определяем метод adjustGamma, который принимает изображение и коэффициент гаммы.
        Затем мы проходим по каждому пикселю на изображении, получаем цвет в формате RGB и изменяем яркость каждого канала отдельно,
        используя формулу Math.pow(color / 255.0f, gamma) * 255.0f. Наконец, мы создаем новый цвет с измененными значениями каналов и
        устанавливаем его для соответствующего пикселя на изображении. В main методе мы вызываем метод adjustGamma дважды с разными значениями коэффициента гаммы для
        преобразования изображения. */
        ImageGamma.imageGamma();

        /* Квантизация изображений (уменьшение цветов изображения). Здесь мы загружаем изображение из файла "img.jpg" и задаем количество бит на каждый цветовой канал (в данном случае 3).
        Затем мы вычисляем размер шага квантования на основе количества бит. Затем мы проходим через каждый пиксель в изображении, квантуем его цвет и
        устанавливаем новое значение цвета для этого пикселя в изображении. Наконец, мы сохраняем измененное изображение в файл "imageQuantization.jpg". */
        ImageQuantization.imageQuantization();

        /* Псевдораскрашивание изображения. Этот код читает изображение в формате JPEG и создает новое изображение, в котором каждый пиксел заменяется цветом на основе его яркости.
        Сначала каждый пиксель конвертируется в оттенки серого, затем значение яркости преобразуется в цвет. В этом примере мы используем синий, зеленый и красный цвета для
        представления темных, средних и светлых областей изображения соответственно. */
        PseudoColoring.pseudoColoring();

        /* Соляризация изображения. Этот код реализует алгоритм соляризации изображения. Алгоритм проходит через каждый пиксель входного изображения, применяет к нему соляризацию и
        устанавливает новый цвет пикселя в выходном изображении.*/
        SolarizeImage.solarizeImage();

        /*--------------------------------------------------------------------------------------------------------------
        Модуль 2 */

        /* Меньше/Больше шума. В данном примере мы используем метод applyFilter(), который принимает исходное изображение и ядро фильтрации в виде двумерного массива.
        Метод проходит по каждому пикселу изображения, применяет ядро фильтрации к окрестности пикселя с помощью свертки и записывает результат в новое изображение.
        Затем мы сохраняем отфильтрованное изображение в файл с помощью класса ImageIO. */
        LowHighPassFilter.lowPassFilter();
        LowHighPassFilter.highPassFilter();

        /* В этом коде используется метод getMedian(), который получает медиану из массива значений. Он сортирует массив и возвращает значение посередине.
        Чтобы применить медианный фильтр к изображению, мы проходим по каждому пикселю и получаем значения его окна.
        Затем мы находим медиану этих значений и устанавливаем ее в пиксель. Размер окна можно задать переменной size. */
        MedianFilter.medianFilter();

        /* Данный код представляет метод Лапласа для обнаружения границ на изображении. */
        MetodLaplasa.metodLaplasa();

        /* Код для метода сдвига и разности применяет метод к каждому пикселю. */
        MetodSdvigRaznost.metodSdvigRaznost();

        /* Применяем оператор Робертса с помощью метода operatorRobertsa(), который возвращает новое изображение с выделенными границами. */
        OperatorRobertsa.operatorRobertsa();

        /* Применяем оператор Собеля с помощью метода operatorSobely(), который возвращает новое изображение с выделенными границами. */
        OperatorSobely.operatorSobely();

        /* Здесь используются два ядра Превитта для вычисления производных по горизонтали и вертикали.
        Затем вычисляется магнитуда каждого пикселя с помощью функции Math.sqrt(), и результат записывается в новый объект BufferedImage. */
        OperatorPrevita.operatorPrevita();

        /* Оператор Кирша - это один из классических операторов обработки изображений, который применяется для выделения границ объектов на изображении.
        Он рассчитывает значение яркости каждого пикселя на основе восьми соседних пикселей и заданного ядра.
        В коде мы используем матрицу 3x3 коэффициентов, которая определяет вес каждого из соседних пикселей. Применение оператора Кирша к
        каждому пикселю изображения помогает выделить контуры объектов формы. */
        OperatorKirsha.operatorKirsha();

        /* Cоздаем пустое изображение с такими же размерами как и оригинальное, проходимся по каждому пикселю оригинального изображения, вычисляем его яркость и
        устанавливаем новый цвет в зависимости от этой яркости.  */
        OperatorTisnenia.operatorTisnenia();

        /* В этом классе мы используем метод createGraphics() для создания объекта Graphics2D, который позволяет нам масштабировать изображение.
        Затем мы используем метод drawImage() для наложения масштабированного изображения на новое пустое изображение. */
        ScaleImage.scaleImage();

        /* Задаем угол поворота в градусах, вычисляем размеры нового изображения после поворота и создаем новое изображение с прозрачным фоном.
        Затем мы настраиваем параметры рендеринга для сглаживания краев при повороте, вычисляем координаты центра изображения,
        создаем объект AffineTransform для поворота изображения и выполняем поворот с использованием метода drawImage() графического контекста.*/
        RotationImage.rotationImage();
    }
}